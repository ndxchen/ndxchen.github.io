(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{282:function(t,v,l){t.exports=l.p+"assets/img/b1.b50ab906.png"},298:function(t,v,l){"use strict";l.r(v);var _=l(13),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"this指向"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[t._v("#")]),t._v(" this指向")]),t._v(" "),_("ul",[_("li",[t._v("默认绑定: 非严格模式下 this 指向全局对象，严格模式下 this 会绑定为 undefined")]),t._v(" "),_("li",[t._v("隐式绑定: 满足 XXX.fn() 格式，fn 的 this 指向 XXX。如果存在链式调用， this 永远指向最后调用它的那个对象")]),t._v(" "),_("li",[t._v("隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。")]),t._v(" "),_("li",[t._v("显式绑定: 通过 call/apply/bind 修改 this 指向")]),t._v(" "),_("li",[t._v("new绑定: 通过 new 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 this 。")]),t._v(" "),_("li",[t._v("箭头函数绑定: 箭头函数没有 this ，它的 this 是通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时优先级")])]),t._v(" "),_("h2",{attrs:{id:"箭头函数与普通函数区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与普通函数区别"}},[t._v("#")]),t._v(" 箭头函数与普通函数区别")]),t._v(" "),_("ul",[_("li",[t._v("箭头函数没有this，它的this是通过作用域链查到外层作用域的this，且指向函数定义时的this而非执行时。")]),t._v(" "),_("li",[t._v("不可以用作构造函数，不能使用new命令，否则会报错")]),t._v(" "),_("li",[t._v("箭头函数没有arguments对象，如果要用，使用rest参数代替")]),t._v(" "),_("li",[t._v("不可以使用yield命令，因此箭头函数不能用作Generator函数。")]),t._v(" "),_("li",[t._v("不能用call/apply/bind修改this指向，但可以通过修改外层作用域的this来间接修改。")]),t._v(" "),_("li",[t._v("箭头函数没有prototype属性")])]),t._v(" "),_("h2",{attrs:{id:"let-const-var-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#let-const-var-区别"}},[t._v("#")]),t._v(" let const var 区别")]),t._v(" "),_("p",[_("strong",[t._v("var")])]),t._v(" "),_("ul",[_("li",[t._v("存在变量提升")]),t._v(" "),_("li",[t._v("可以重复声明")]),t._v(" "),_("li",[t._v("在函数中使用var声明变量的时候，该变量是局部的")])]),t._v(" "),_("p",[_("strong",[t._v("let")])]),t._v(" "),_("ul",[_("li",[t._v("不存在变量提升，let声明变量前，该变量不能使用（暂时性死区）")]),t._v(" "),_("li",[t._v("let命令所在的代码块内有效，在块级作用域内有效")]),t._v(" "),_("li",[t._v("let不允许在相同作用域中重复声明，注意是相同作用域，不同作用域有重复声明不会报错")])]),t._v(" "),_("p",[_("strong",[t._v("const")])]),t._v(" "),_("ul",[_("li",[t._v("const声明一个只读的变量，声明后，值就不能改变")]),t._v(" "),_("li",[t._v("const必须初始化")]),t._v(" "),_("li",[t._v("const并不是变量的值不能改动，而是变量指向的内存地址所保存的数据不得改动")])]),t._v(" "),_("p",[_("strong",[t._v("区别")])]),t._v(" "),_("p",[_("strong",[t._v("1.变量提升")])]),t._v(" "),_("ul",[_("li",[t._v("var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined")]),t._v(" "),_("li",[t._v("let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错")])]),t._v(" "),_("p",[_("strong",[t._v("2.块级作用域")])]),t._v(" "),_("ul",[_("li",[t._v("var不存在块级作用域")]),t._v(" "),_("li",[t._v("let和const存在块级作用域")])]),t._v(" "),_("p",[_("strong",[t._v("3.重复声明")])]),t._v(" "),_("ul",[_("li",[t._v("var允许重复声明变量")]),t._v(" "),_("li",[t._v("let和const在同一作用域不允许重复声明变量")])]),t._v(" "),_("p",[_("strong",[t._v("4.修改声明的变量")])]),t._v(" "),_("ul",[_("li",[t._v("var和let可以")]),t._v(" "),_("li",[t._v("const声明一个只读的常量。一旦声明，常量的值就不能改变，但对于对象和数据这种引用类型，内存地址不能修改，可以修改里面的值。")])]),t._v(" "),_("h2",{attrs:{id:"call、apply、bind区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#call、apply、bind区别"}},[t._v("#")]),t._v(" call、apply、bind区别")]),t._v(" "),_("ul",[_("li",[t._v("call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。")]),t._v(" "),_("li",[t._v("call()和apply()的区别就在于，两者之间的参数。")]),t._v(" "),_("li",[t._v("call()在第一个参数之后的 后续所有参数就是传入该函数的值。")]),t._v(" "),_("li",[t._v("apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。")]),t._v(" "),_("li",[t._v("bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。")])]),t._v(" "),_("h2",{attrs:{id:"cookie-localstorage-sessionstorage区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie-localstorage-sessionstorage区别"}},[t._v("#")]),t._v(" cookie, localStorage, sessionStorage区别")]),t._v(" "),_("br"),t._v(" "),_("p"),_("p",[_("img",{attrs:{src:l(282),alt:"alt"}})]),_("p"),t._v(" "),_("h2",{attrs:{id:"new操作符做了哪些事情"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#new操作符做了哪些事情"}},[t._v("#")]),t._v(" new操作符做了哪些事情")]),t._v(" "),_("ul",[_("li",[t._v("1.创建了一个新对象")]),t._v(" "),_("li",[t._v("2.把这个新对象的原型属性（proto）绑定到原函数的prototype属性（就是继承原函数原型）")]),t._v(" "),_("li",[t._v("3.把原函数的this指向转移到这个新对象上")]),t._v(" "),_("li",[t._v("4.返回新对象，如果这个函数没有返回其他对象的话")])])])}),[],!1,null,null,null);v.default=s.exports}}]);